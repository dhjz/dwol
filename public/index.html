<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å±€åŸŸç½‘å”¤é†’å·¥å…·</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <div id="app">
    <div v-if="loading" class="container">
      <div class="login-box">
        <div class="login-title">â³ åŠ è½½ä¸­...</div>
      </div>
    </div>

    <div v-else-if="!isLoggedIn && passwordRequired" class="container">
      <div class="login-box">
        <div class="login-title">ğŸ” ç™»å½•éªŒè¯</div>
        <div class="form-group">
          <input type="password" v-model="password" @keyup.enter="login" class="form-input" placeholder="è¯·è¾“å…¥å¯†ç ">
        </div>
        <button @click="login" class="btn btn-blue btn-full">ç™»å½•</button>
      </div>
    </div>

    <div v-else class="container">
      <header class="header">
        <div class="title">âš¡ å±€åŸŸç½‘å”¤é†’å·¥å…·</div>
        <div class="subtitle">Wake on LAN Tool</div>
      </header>

      <div class="top-actions">
        <div @click="toggleTheme" class="top-action">{{ isDarkMode ? 'â˜€ï¸' : 'ğŸŒ™' }}</div>
        <div v-if="passwordRequired" @click="logout" class="top-action">ğŸšª</div>
      </div>

      <div class="toolbar">
        <button @click="showAddModal = true" class="btn btn-blue">â• æ·»åŠ ä¸»æœº</button>
        <button @click="checkStatus" class="btn btn-purple">ğŸ” æ£€æŸ¥çŠ¶æ€</button>
        <button @click="exportData" class="btn">ğŸ“¤ å¯¼å‡ºæ•°æ®</button>
        <button @click="triggerImport" class="btn">ğŸ“¥ å¯¼å…¥æ•°æ®</button>
        <input type="file" ref="fileInput" @change="importData" accept=".json" style="display: none;">
      </div>

      <div v-if="machines.length === 0" class="empty-state">
        <div class="empty-icon">ğŸ’»</div>
        <p>æš‚æ— ä¸»æœºï¼Œç‚¹å‡»"æ·»åŠ ä¸»æœº"å¼€å§‹ä½¿ç”¨</p>
      </div>

      <div v-else class="machine-list">
        <div v-for="machine in machines" :key="machine.id" class="machine-item">
          <div class="machine-info">
            <div class="machine-name">
              {{ machine.name ? machine.name + ' - ' + machine.host : machine.host }}
              <span v-if="machine.status" class="status-badge" :class="'status-' + machine.status">
                {{ getStatusText(machine.status) }} <span v-if="machine.statusMethod"> ({{ machine.statusMethod }})</span>
              </span>
            </div>
            <div class="machine-detail">
              <span>ğŸŒ {{ machine.mac }}</span>
              <span>ğŸ”Œ ç«¯å£: {{ machine.port }}</span>
            </div>
          </div>
          <div class="machine-actions">
            <button @click="confirmWake(machine)" class="btn btn-green">âš¡ å”¤é†’</button>
            <button @click="testPort(machine)" class="btn">ğŸ”Œ æµ‹è¯•</button>
            <button @click="editMachine(machine)" class="btn">âœï¸</button>
            <button @click="deleteMachine(machine.id)" class="btn btn-red">ğŸ—‘ï¸</button>
          </div>
        </div>
      </div>
    </div>

    <div v-if="showAddModal" class="modal-overlay" @click.self="showAddModal = false">
      <div class="modal">
        <div class="modal-title">{{ editingMachine ? 'ç¼–è¾‘ä¸»æœº' : 'æ·»åŠ ä¸»æœº' }}</div>
        <div class="form-group">
          <input type="text" v-model="form.host" class="form-input" placeholder="ä¸»æœºåœ°å€ (IPæˆ–åŸŸåï¼Œå¯é€‰)">
        </div>
        <div class="form-group">
          <input type="text" v-model="form.mac" class="form-input" placeholder="MACåœ°å€ (æ”¯æŒ:æˆ–-åˆ†éš”æˆ–æ— åˆ†éš”)">
        </div>
        <div class="form-group">
          <input type="number" v-model="form.port" class="form-input" placeholder="ç½‘ç»œç«¯å£ (é»˜è®¤9)">
        </div>
        <div class="form-group">
          <input type="text" v-model="form.name" class="form-input" placeholder="è®¾å¤‡åç§° (å¯é€‰)">
        </div>
        <div class="modal-buttons">
          <button @click="closeModal" class="btn">å–æ¶ˆ</button>
          <button @click="saveMachine" class="btn btn-green">ç¡®å®š</button>
        </div>
      </div>
    </div>

    <div v-if="showWakeModal" class="modal-overlay" @click.self="showWakeModal = false">
      <div class="modal">
        <div class="modal-title">âš¡ ç¡®è®¤å”¤é†’</div>
        <p style="color: #aaa; margin-bottom: 20px;">
          ç¡®å®šè¦å”¤é†’ä¸»æœº <strong style="color: #00f5ff;">{{ selectedMachine?.name || selectedMachine?.host || 'æœªå‘½åä¸»æœº' }}</strong> å—ï¼Ÿ
        </p>
        <div class="modal-buttons">
          <button @click="showWakeModal = false" class="btn">å–æ¶ˆ</button>
          <button @click="wakeMachine" class="btn btn-green">ç¡®è®¤å”¤é†’</button>
        </div>
      </div>
    </div>
  </div>

  <script src="vue.global.prod.js"></script>
  <script>
    const { createApp } = Vue;

    createApp({
      data() {
        return {
          loading: true,
          isLoggedIn: false,
          passwordRequired: false,
          password: '',
          isDarkMode: true,
          machines: [],
          showAddModal: false,
          showWakeModal: false,
          selectedMachine: null,
          editingMachine: null,
          form: {
            id: '',
            name: '',
            host: '',
            mac: '',
            port: 9
          }
        };
      },
      mounted() {
        this.loadTheme();
        this.checkAuthStatus();
      },
      methods: {
        loadTheme() {
          const savedTheme = localStorage.getItem('wol_theme');
          if (savedTheme !== null) {
            this.isDarkMode = savedTheme === 'dark';
          } else {
            this.isDarkMode = true;
          }
          this.applyTheme();
        },
        applyTheme() {
          if (this.isDarkMode) {
            document.body.classList.remove('light-mode');
          } else {
            document.body.classList.add('light-mode');
          }
        },
        toggleTheme() {
          this.isDarkMode = !this.isDarkMode;
          localStorage.setItem('wol_theme', this.isDarkMode ? 'dark' : 'light');
          this.applyTheme();
        },
        async checkAuthStatus() {
          try {
            const response = await fetch('/api/auth/status');
            if (response.ok) {
              const data = await response.json();
              this.passwordRequired = data.required;
              
              if (!this.passwordRequired) {
                this.isLoggedIn = true;
                await this.loadMachines();
                this.checkStatus()
              } else {
                const savedPassword = localStorage.getItem('wol_password');
                if (savedPassword) {
                  await this.verifyPassword(savedPassword);
                }
              }
            }
          } catch (error) {
            console.error('Failed to check auth status:', error);
          } finally {
            this.loading = false;
          }
        },
        async verifyPassword(pwd) {
          try {
            const response = await fetch('/api/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ password: pwd })
            });

            if (response.ok) {
              this.isLoggedIn = true;
              this.password = pwd;
              localStorage.setItem('wol_password', pwd);
              await this.loadMachines();
              this.checkStatus()
              return true;
            }
            return false;
          } catch (error) {
            console.error('Failed to verify password:', error);
            return false;
          }
        },
        async login() {
          if (!this.password.trim()) {
            alert('è¯·è¾“å…¥å¯†ç ');
            return;
          }

          const success = await this.verifyPassword(this.password);
          if (!success) {
            alert('å¯†ç é”™è¯¯');
          }
        },
        logout() {
          localStorage.removeItem('wol_password');
          this.isLoggedIn = false;
          this.password = '';
          this.machines = [];
        },
        async loadMachines() {
          try {
            const response = await fetch('/api/machines');
            if (response.ok) {
              this.machines = await response.json();
            }
          } catch (error) {
            console.error('Failed to load machines:', error);
          }
        },
        async saveMachine() {
          if (!this.form.mac.trim()) {
            alert('MACåœ°å€ä¸èƒ½ä¸ºç©º');
            return;
          }

          const machine = {
            id: this.form.id || Date.now().toString(),
            name: this.form.name.trim(),
            host: this.form.host.trim(),
            mac: this.form.mac.trim(),
            port: parseInt(this.form.port) || 9
          };

          try {
            const method = this.editingMachine ? 'PUT' : 'POST';
            const response = await fetch('/api/machines', {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(machine)
            });

            if (response.ok) {
              await this.loadMachines();
              this.closeModal();
            } else {
              alert('ä¿å­˜å¤±è´¥');
            }
          } catch (error) {
            console.error('Failed to save machine:', error);
            alert('ä¿å­˜å¤±è´¥');
          }
        },
        closeModal() {
          this.showAddModal = false;
          this.resetForm();
        },
        editMachine(machine) {
          this.editingMachine = machine;
          this.form = {
            id: machine.id,
            name: machine.name,
            host: machine.host,
            mac: machine.mac,
            port: machine.port
          };
          this.showAddModal = true;
        },
        async deleteMachine(id) {
          if (!confirm('ç¡®å®šè¦åˆ é™¤è¯¥ä¸»æœºå—ï¼Ÿ')) {
            return;
          }

          try {
            const response = await fetch(`/api/machines?id=${id}`, {
              method: 'DELETE'
            });

            if (response.ok) {
              await this.loadMachines();
            } else {
              alert('åˆ é™¤å¤±è´¥');
            }
          } catch (error) {
            console.error('Failed to delete machine:', error);
            alert('åˆ é™¤å¤±è´¥');
          }
        },
        confirmWake(machine) {
          this.selectedMachine = machine;
          this.showWakeModal = true;
        },
        async wakeMachine() {
          if (!this.selectedMachine) return;

          try {
            const response = await fetch('/api/wake', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id: this.selectedMachine.id })
            });

            if (response.ok) {
              alert('å”¤é†’æˆåŠŸï¼');
              await this.loadMachines();
            } else {
              alert('å”¤é†’å¤±è´¥');
            }
          } catch (error) {
            console.error('Failed to wake machine:', error);
            alert('å”¤é†’å¤±è´¥');
          }

          this.showWakeModal = false;
          this.selectedMachine = null;
        },
        async exportData() {
          try {
            const response = await fetch('/api/export');
            if (response.ok) {
              const blob = await response.blob();
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'machines.json';
              a.click();
              URL.revokeObjectURL(url);
            }
          } catch (error) {
            console.error('Failed to export data:', error);
            alert('å¯¼å‡ºå¤±è´¥');
          }
        },
        triggerImport() {
          this.$refs.fileInput.click();
        },
        async importData(event) {
          const file = event.target.files[0];
          if (!file) return;

          try {
            const text = await file.text();
            const machines = JSON.parse(text);

            const response = await fetch('/api/import', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(machines)
            });

            if (response.ok) {
              alert('å¯¼å…¥æˆåŠŸ');
              await this.loadMachines();
            } else {
              alert('å¯¼å…¥å¤±è´¥');
            }
          } catch (error) {
            console.error('Failed to import data:', error);
            alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼é”™è¯¯');
          }

          event.target.value = '';
        },
        resetForm() {
          this.form = {
            id: '',
            name: '',
            host: '',
            mac: '',
            port: 9
          };
          this.editingMachine = null;
        },
        async checkStatus() {
          try {
            const response = await fetch('/api/status');
            if (response.ok) {
              const statuses = await response.json();
              
              this.machines.forEach(machine => {
                const status = statuses.find(s => s.id === machine.id);
                if (status) {
                  machine.status = status.status;
                  machine.statusMethod = status.method;
                }
              });
            } else {
              alert('æ£€æŸ¥çŠ¶æ€å¤±è´¥');
            }
          } catch (error) {
            console.error('Failed to check status:', error);
            alert('æ£€æŸ¥çŠ¶æ€å¤±è´¥');
          }
        },
        getStatusText(status) {
          const statusMap = {
            'online': 'ğŸŸ¢',
            'offline': 'ğŸ”´',
            'unknown': 'âšª'
          };
          return statusMap[status] || 'âšª';
        },
        async testPort(machine) {
          if (!machine.host) {
            alert('è¯¥ä¸»æœºæ²¡æœ‰è®¾ç½®IPåœ°å€ï¼Œæ— æ³•æµ‹è¯•ç«¯å£');
            return;
          }

          const port = prompt(`è¯·è¾“å…¥è¦æµ‹è¯•çš„ç«¯å£å· (1-65535)ï¼ˆè¶…æ—¶æ—¶é—´3ç§’ï¼‰:`, '80');
          if (port === null) {
            return;
          }

          const portNum = parseInt(port);
          if (isNaN(portNum) || portNum <= 0 || portNum > 65535) {
            alert('ç«¯å£å·æ— æ•ˆï¼Œè¯·è¾“å…¥1-65535ä¹‹é—´çš„æ•°å­—');
            return;
          }

          try {
            const response = await fetch('/api/test-port', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ host: machine.host, port: portNum })
            });

            if (response.ok) {
              const result = await response.json();
              if (result.connected) {
                alert(`âœ… ç«¯å£ ${portNum} è¿æ¥æˆåŠŸï¼`);
              } else {
                alert(`âŒ ç«¯å£ ${portNum} è¿æ¥å¤±è´¥æˆ–è¶…æ—¶`);
              }
            } else {
              alert('æµ‹è¯•ç«¯å£å¤±è´¥');
            }
          } catch (error) {
            console.error('Failed to test port:', error);
            alert('æµ‹è¯•ç«¯å£å¤±è´¥');
          }
        }
      }
    }).mount('#app');
  </script>
</body>
</html>
